```javascript
//修改this
function bindThis(f, oTarget) {
  let args = Array.prototype.slice.call(arguments, 2);
  return function () {
    return f.apply(oTarget, Array.prototype.slice.call(arguments).concat(args));
  };
}
// url参数
function getUrlParam(sUrl, sKey) {
  var paramArr = sUrl.split("?")[1].split("#")[0].split("&"); // 取出每个参数的键值对放入数组
  const obj = {};
  paramArr.forEach((element) => {
    const [key, value] = element.split("="); // 取出数组中每一项的键与值
    if (obj[key] === void 0) {
      // 表示第一次遍历这个元素，直接添加到对象上面
      obj[key] = value;
    } else {
      obj[key] = [].concat(obj[key], value); // 表示不是第一次遍历说明这个键已有，通过数组存起来。
    }
  });
  return sKey === void 0 ? obj : obj[sKey] || ""; // 如果该方法为一个参数，则返回对象。
  //如果为两个参数，sKey存在，则返回值或数组，否则返回空字符。
}
//查找节点
function commonParentNode(oNode1, oNode2) {
  while (true) {
    oNode1 = oNode1.parentNode;
    if (oNode1.contains(oNode2)) {
      return oNode1;
    }
  }
}
```

.3.6. 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？ 
（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法， 将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了 非法字符，如果存在非法字 符，则对非法字符进行转义后再进行下一过程。 
（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么 就直接使用，否则向服务器发起新 的请求。 
（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有 该域名的 IP 地址的缓存，如果 有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓 存，如果没有就会先向根域 名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得 负责的权威域名服务器的地 址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用 户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起 请求属于迭代请求。 
（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数 据给传输层，TCP 协议会指定源
端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址 作为目的地址。然后将下发给 数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地 址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请 求主机在同一个子网里，如果 在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子 网里，那么我们的请求应该 转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此 时目的主机的 MAC 地址应 该为网关的地址。 
（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报 文段和一个随机序号，服务端接 收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随 机序号。客户端接收服务器的 确认应答后，进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段，服务器端接收 到确认后，也进入连接建立 状态，此时双方的连接就建立起来了。 
（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端 向服务器端发送使用的协议的版 本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送 一个随机数和自己的数字证 书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书 中的公钥对随机数加密，然后 发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收 后，使用自己的私钥对数据解 密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个 随机数，按照之前所约定的加
密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后 再传输。 
（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到 响应后，开始对 html 文件进行 解析，开始页面的渲染过程。 
（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如 果遇到 script 标签，则判端 是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。 当 DOM 树和 CSSOM 树建 立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最 后使用浏览器的 UI 接口对页 面进行绘制。这个时候整个页面就显示出来了。 
（9）最后一步是 TCP 断开连接的四次挥手过程。

简单介绍一下 V8 引擎的垃圾回收机制
 v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是 新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了 新生代和老生代。新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次 垃圾回收的对象被称为老生代。 新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收 结束后再继续执行。
 这个算法分为三步： 
 （1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件， 如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。 
 （2）如果对象不存活，则释放对象的空间。 
 （3）最后将 From 空间和 To 空间角色进行交换。
  新生代对象晋升到老生代有两个条件：
   （1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空 间复制到老生代中；若没有经历，则复制到 To 空间。 
   （2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时， 若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束 后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。 老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记 结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存 分配。所以了解决内存碎片的问题引入了标记压缩法。
由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不 会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问 题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运 行逻辑执行一会，就这样交替运行。
